{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/unexpected/node_modules/@identity-connect/crypto/src/encrDecr.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/crypto/src/errors.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/crypto/src/utils.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/crypto/src/securedEnvelope.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/crypto/src/serialization.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/crypto/src/walletAccounts.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519Signature, PublicKey, Signature } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport nacl from 'tweetnacl';\nimport ed2curve from 'ed2curve';\nimport { DecryptionError } from './errors';\nimport {\n  concatUint8array,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  KeyTypes,\n  toKey,\n  X25519PublicKey,\n  X25519SecretKey,\n} from './utils';\n\n// This callback takes in a message bytes, and signs it.\n// THIS DOES NOT PERFORM DOMAIN SEPARATION: IT IS ASSUMED OUR LIBRARY ALREADY DID IT.\n// This is to support hardware wallets.\nexport type SignCallback = (message: Uint8Array) => Promise<Signature>;\n\nexport type SignaturePurpose = 'TRANSPORT_KEYPAIR' | 'ACCOUNT_INFO' | 'SECURED_ENVELOPE';\n\nexport const SIGNATURE_PREFIX = 'APTOS::IDENTITY_CONNECT';\n\nexport type EncryptionResult = {\n  nonce: Uint8Array;\n  secured: Uint8Array;\n};\n\nexport type SerializedEncryptionResult = {\n  nonceB64: string;\n  securedB64: string;\n};\n\n/**\n * Converts an Ed25519 public key to an X25519 public key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519PublicKey The Ed25519 public key to convert\n * @param errorKeyName The name of the key to use in error messages\n */\nexport function convertEd25519PublicKeyToX25519PublicKey(\n  ed25519PublicKey: Ed25519PublicKey,\n  errorKeyName: string,\n): X25519PublicKey {\n  const x25519PublicKey = ed2curve.convertPublicKey(ed25519PublicKey.key.slice(0, 32));\n  if (!x25519PublicKey) throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);\n  return toKey(x25519PublicKey, KeyTypes.X25519PublicKey);\n}\n\n/**\n * Converts an Ed25519 secret key to an X25519 secret key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519SecretKey The Ed25519 secret key to convert\n */\nexport function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey: Ed25519SecretKey): X25519SecretKey {\n  const x25519SecretKey = ed2curve.convertSecretKey(ed25519SecretKey.key.slice(0, 32));\n  return toKey(x25519SecretKey, KeyTypes.X25519SecretKey);\n}\nexport function serializeEncryptionResult(enc: EncryptionResult): SerializedEncryptionResult {\n  return {\n    nonceB64: encodeBase64(enc.nonce),\n    securedB64: encodeBase64(enc.secured),\n  };\n}\n\nexport function deserializeEncryptionResult(enc: SerializedEncryptionResult): EncryptionResult {\n  return {\n    nonce: decodeBase64(enc.nonceB64),\n    secured: decodeBase64(enc.securedB64),\n  };\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResult<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObject<T>(senderX25519PublicKey, receiverEd25519SecretKey, des.secured, des.nonce);\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResultDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObjectDirect<T>(senderX25519PublicKey, receiverX25519SecretKey, des.secured, des.nonce);\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessage(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Encrypt the message with the receiver's public key and sender's secret key\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessageDirect(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Generate a random nonce\n  const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n  // Convert the message to a Uint8Array\n  const messageUint8 = new TextEncoder().encode(message);\n\n  const secured = nacl.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));\n\n  return { nonce, secured };\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObject<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: T,\n): EncryptionResult {\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObjectDirect<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: T,\n): EncryptionResult {\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessage(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  // Decrypt the message with the receiver's secret key and sender's public key\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessageDirect(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  let decryptedUint8;\n  try {\n    decryptedUint8 = nacl.box.open(\n      securedMessage,\n      nonce,\n      senderX25519PublicKey.key.slice(0, 32),\n      receiverX25519SecretKey.key.slice(0, 32),\n    );\n  } catch (e: any) {\n    throw new DecryptionError(`Could not decrypt message: ${e.message}`);\n  }\n  if (!decryptedUint8) throw new DecryptionError('Could not decrypt message');\n\n  // Convert the decrypted Uint8Array back to a string\n  return new TextDecoder().decode(decryptedUint8);\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObject<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptObjectDirect<T>(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObjectDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n  return JSON.parse(decryptedStr) as T;\n}\n\n/**\n * Hashes a message with a purpose-specific prefix using SHA-3 256-bit algorithm.\n * The purpose prefix is constructed as `'APTOS::IDENTITY_CONNECT' + '::' + purpose + '::'`\n * This is to prevent hash collisions with other services, uses, and purposes\n * @param message The message to hash as a Uint8Array.\n * @param purpose The purpose of the signature.\n * @returns Uint8Array The hashed message as a Uint8Array\n */\nexport function messageHash(message: Uint8Array, purpose: SignaturePurpose) {\n  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));\n  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));\n}\n\nexport function signWithEd25519SecretKey(\n  message: Uint8Array,\n  signingEd25519SecretKey: Ed25519SecretKey,\n  purpose: SignaturePurpose,\n) {\n  return nacl.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);\n}\n\n// This assumes that domain separation has already happened: this emulates the behavior of a hardware device\nexport function makeEd25519SecretKeySignCallbackNoDomainSeparation(\n  signingEd25519SecretKey: Ed25519SecretKey,\n): SignCallback {\n  return async (message: Uint8Array) => new Ed25519Signature(nacl.sign.detached(message, signingEd25519SecretKey.key));\n}\n\nexport function verifySignature(\n  message: Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  return signingPublicKey.verifySignature({ message: messageHash(message, purpose), signature });\n}\n\nexport function hashAndVerifySignature(\n  message: string | Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  const messageUint8 = message instanceof Uint8Array ? message : new TextEncoder().encode(message);\n  const messageUint8Hash = sha3_256(messageUint8);\n  return verifySignature(messageUint8Hash, signature, signingPublicKey, purpose);\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport class EncryptionEnvelopeError extends Error {}\n\nexport class EnvelopeMessageMismatchError extends EncryptionEnvelopeError {\n  constructor(\n    message: string,\n    public field: string,\n  ) {\n    super(message);\n    this.name = 'EnvelopeMessageMismatchError';\n    Object.setPrototypeOf(this, EnvelopeMessageMismatchError.prototype);\n  }\n}\n\nexport class DecryptionError extends EncryptionEnvelopeError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DecryptionError';\n    Object.setPrototypeOf(this, DecryptionError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl';\n\nexport enum KeyTypes {\n  'Ed25519PublicKey' = 'Ed25519PublicKey',\n  'Ed25519SecretKey' = 'Ed25519SecretKey',\n  'X25519PublicKey' = 'X25519PublicKey',\n  'X25519SecretKey' = 'X25519SecretKey',\n}\n\nexport interface IKey<Type extends KeyTypes> {\n  key: Uint8Array;\n  type: Type;\n}\n\nexport type X25519PublicKey = IKey<KeyTypes.X25519PublicKey>;\nexport type X25519SecretKey = IKey<KeyTypes.X25519SecretKey>;\nexport type X25519KeyPair = {\n  publicKey: X25519PublicKey;\n  secretKey: X25519SecretKey;\n};\n\nexport type Ed25519PublicKey = IKey<KeyTypes.Ed25519PublicKey>;\nexport type Ed25519SecretKey = IKey<KeyTypes.Ed25519SecretKey>;\nexport type Ed25519KeyPair = {\n  publicKey: Ed25519PublicKey;\n  secretKey: Ed25519SecretKey;\n};\n\nexport type RawKeyPair = {\n  publicKey: Uint8Array;\n  secretKey: Uint8Array;\n};\n\nexport function createX25519KeyPair(): X25519KeyPair {\n  return keypairToX25519(nacl.box.keyPair());\n}\n\nexport function createEd25519KeyPair(): Ed25519KeyPair {\n  return keypairToEd25519(nacl.sign.keyPair());\n}\n\nexport function toKey<Type extends KeyTypes = KeyTypes>(\n  rawKey: Uint8Array,\n  type: Type,\n): Type extends KeyTypes.Ed25519PublicKey\n  ? Ed25519PublicKey\n  : Type extends KeyTypes.Ed25519SecretKey\n    ? Ed25519SecretKey\n    : Type extends KeyTypes.X25519PublicKey\n      ? X25519PublicKey\n      : Type extends KeyTypes.X25519SecretKey\n        ? X25519SecretKey\n        : never {\n  return {\n    key: rawKey,\n    type,\n  } as any;\n}\n\nexport function keypairToEd25519(keyPair: RawKeyPair): Ed25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.Ed25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.Ed25519SecretKey),\n  };\n}\n\nexport function keypairToX25519(keyPair: RawKeyPair): X25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.X25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.X25519SecretKey),\n  };\n}\n\nexport function aptosAccountToEd25519Keypair(account: { signingKey: nacl.SignKeyPair }) {\n  return ed25519KeypairFromSecret(account.signingKey.secretKey);\n}\n\nexport function ed25519KeypairFromSecret(ed25519SecretKeyBytes: Uint8Array): Ed25519KeyPair {\n  return keypairToEd25519(nacl.sign.keyPair.fromSeed(ed25519SecretKeyBytes.slice(0, 32)));\n}\n\nexport function decodeBase64(base64Str: string): Uint8Array {\n  if (globalThis.Buffer) {\n    return new Uint8Array(Buffer.from(base64Str, 'base64'));\n  }\n  return Uint8Array.from(atob(base64Str), (m) => m.codePointAt(0)!);\n}\n\nexport function encodeBase64(bytes: Uint8Array): string {\n  if (globalThis.Buffer) {\n    return Buffer.from(bytes).toString('base64');\n  }\n  return btoa(Array.from(bytes, (x) => String.fromCodePoint(x)).join(''));\n}\n\nexport function concatUint8array(arrayOne: Uint8Array, arrayTwo: Uint8Array): Uint8Array {\n  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n  mergedArray.set(arrayOne);\n  mergedArray.set(arrayTwo, arrayOne.length);\n  return mergedArray;\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519PublicKey as AptosEd25519PublicKey, Ed25519Signature, Hex } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport {\n  createX25519KeyPair,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  X25519KeyPair,\n  KeyTypes,\n  toKey,\n  X25519PublicKey,\n} from './utils';\nimport { EnvelopeMessageMismatchError } from './errors';\nimport {\n  SerializedEncryptionResult,\n  SignCallback,\n  decryptObject,\n  encryptObject,\n  serializeEncryptionResult,\n  deserializeEncryptionResult,\n  verifySignature,\n  signWithEd25519SecretKey,\n} from './encrDecr';\n\n/**\n * When sending messages back and forth, there are some things that Identity Connect must know to function and provide\n * security for users, and dApps and wallets need to know that any messages sent to one another were sent (and\n * received) by the expected parties.\n *\n * To allow for secure communication between parties, we are introducing the\n * *SecuredEnvelope*. This envelope provides a secure channel for parties to encrypt private messages, *and*\n * authenticate one another, while allowing IC to route requests and block invalid messages.\n *\n * The envelope can be thought of as a wrapper around the JSON payload of a POST/PUT request T, and has two parts:\n * `messagePrivate`: This contains some of the parameters of `T`, which will be signed by the sender and encrypted\n *                   with the recipient's public key.\n * `publicMessage`: This field is sent unencrypted, but signed so that the IC endpoint can do basic validation before\n *                  processing. The parameters in `publicMessage` are DISJOINT from `messagePrivate`, and are invalid\n *                  otherwise: there are no keys in `messagePrivate` that also appear in `publicMessage`. It must\n *                  contain a ``_metadata`` field with security features like the timestamp, public keys, sequence\n *                  number, etc.\n *\n * Both IC and dApps can verify, on chain, that the senders’ keys match their address and that they are speaking\n * with who they expect. Encryption is done with an X25519 key derived from the ED25519 PublicKey of the wallet\n * account that is connecting (this allows for seamless cross-device account access), and an ephemeral X25519 KeyPair,\n * of which the SecretKey is thrown away after encryption. Decryption uses the X25519 key derived from the receiver\n * ED25519 SecretKey.\n *\n * Account private keys Ska (and their counterpart X25519 keys) are only used to decrypt and sign:\n * THEY ARE NEVER USED TO ENCRYPT!\n *\n * Operations follow the Cryptographic Doom Principle:\n *   Always verify the signature of the message before any other cryptographic operations\n * https://moxie.org/2011/12/13/the-cryptographic-doom-principle.html\n *\n *\n * To send a `SecuredEnvelope` over the wire, it must first be turned into a `SecuredEnvelopeTransport` - this\n * involves:\n * 1. Encrypting and serializing the `privateMessage` field to an `encryptedPrivateMessage`field.\n *     a. Generate ephemeral X25519 sender keypair `xPkse/xSkse`. The `xPkse` becomes the `senderX25519PublicKeyB64` in\n *      the `EnvelopeMetadata`.\n *     b. Convert the `receiverEd25519PublicKey` to a `receiverX25519PublicKey` - `xPkr`\n *     c. Generate a random `nonce` for the `[nacl.box](http://nacl.box)` encryption\n *     d. Encrypt the `privateMessage` using `[nacl.box](http://nacl.box)` with the `xSkse` and `xPkr`\n *     e. Package this encrypted data, and the `nonce`, into a `SerializedEncryptionResult`\n * 2. JSON serializing the `publicMessage` field into a `serializedPublicMessage`. We don’t care about canonical\n *    serialization/ordering as the sender signs over this serialized string.\n * 3.  Now that we have the private `encryptedPrivateMessage` and public `serializedPublicMessage` we can generate the\n *    `messageSignature`:\n *     a. Hash the `SHA3-256(encryptedPublicMessage)` to get `publicMessageHash`\n *     b. Hash the `SHA3-256(encryptedPrivateMessage)` to get `privateMessageHash`\n *     c. Hash `SHA3-256(publicMessageHash | privateMessageHash)` to get `combinedMessageHash`\n *     d. Get the `domainSeparatedMessageHash` by hashing the `combinedMessageHash` with a domain separator:\n *        `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | combinedMessageHash)`\n *     e. To obtain the final `messageSignature`, we sign the `domainSeparatedMessageHash` with the Ed25519 private\n *        key of the sender, and hex encode it.\n * 4. This creates the final `SecuredEnvelopeTransport` object, ready to be JSON serialized and sent in an HTTP\n *    request\n */\n\nexport const REQUIRED_FIELDS: (keyof EnvelopeMetadata)[] = [\n  'receiverEd25519PublicKeyB64',\n  'senderEd25519PublicKeyB64',\n  'senderX25519PublicKeyB64',\n  'sequence',\n  'timestampMillis',\n].sort() as (keyof EnvelopeMetadata)[];\n\n// The publicMessage._metadata field looks like this:\nexport type EnvelopeMetadata = {\n  // The receiver's public key, base64\n  receiverEd25519PublicKeyB64: string;\n  // The sender public key, base64\n  senderEd25519PublicKeyB64: string;\n  // The senders X25519 public key, base64\n  senderX25519PublicKeyB64: string;\n  // The sequence of the sender.\n  // This number only goes up, to prevent relay attacks\n  // This exists per pairing\n  // dApps, wallets, accounts, etc are expected to keep track of them\n  // IC will reject out-of-order sequence numbers\n  sequence: number;\n  // The timestamp this message was sent at\n  // IC will reject if it's in the future or older than 5 minutes\n  timestampMillis: number;\n};\n\nexport interface IEnvelopeMetadata extends Message {\n  _metadata: EnvelopeMetadata;\n}\n\n// A message- whether the `Public` or `Private` component- is a JSON object.\n// As such, we know that the keys are strings, and the values are any JSON-serializable type ('unknown')\nexport type Message = Record<string, unknown>;\n\nexport type SecuredEnvelope<Public extends Message> = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type SecuredEnvelopeTransport = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  serializedPublicMessage: string;\n};\n\nexport type DecryptedEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n> = {\n  messageSignature: string;\n  privateMessage: Private;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type DeserializedTransportEnvelope<Public extends Message> = SecuredEnvelopeTransport & SecuredEnvelope<Public>;\n\nexport type SignCallbackOrEd25519SecretKey = SignCallback | Ed25519SecretKey;\n\nexport function ensurePrivatePublicFieldsDisjoint<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(privateMessage: Private, publicMessage: Public) {\n  // gets all fields in privateMessage that are also in publicMessage\n  const intersection = Object.keys(privateMessage).filter((x) => Object.keys(publicMessage).includes(x));\n  if (intersection.length > 0) {\n    const field = intersection[0];\n    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);\n  }\n}\n\nexport function ensureMetadataFields(message: EnvelopeMetadata) {\n  // ensure ONLY the fields in REQUIRED_FIELDS are present in message. Sort asc.\n  const messageKeys = Object.keys(message).sort();\n  const extraFields = messageKeys.filter((key) => !REQUIRED_FIELDS.includes(key as any));\n  const missingFields = REQUIRED_FIELDS.filter((key) => !messageKeys.includes(key as any));\n  if (extraFields.length > 0 || missingFields.length > 0) {\n    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(', ')})` : '';\n    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(', ')})` : '';\n    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;\n    throw new EnvelopeMessageMismatchError(\n      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,\n      '_metadata',\n    );\n  }\n}\n\nexport function deserializeTransportEnvelope<Public extends Message>(\n  transportEnvelope: SecuredEnvelopeTransport,\n): DeserializedTransportEnvelope<Public> {\n  const publicMessage = JSON.parse(transportEnvelope.serializedPublicMessage) as Public & IEnvelopeMetadata;\n  return {\n    ...transportEnvelope,\n    publicMessage,\n  };\n}\n\n// This signs with the senders ed25519 private key,\n// but encrypts with an ephemeral X25519 keyPair + the receivers x25519 public key (converted from their ed25519 key)\n// This is so that the private key IS ONLY EVER USED FOR DECRYPTION, NEVER FOR ENCRYPTION\nexport function encryptAndSignEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  publicMessage: Public,\n  privateMessage: Private,\n): SecuredEnvelopeTransport {\n  const senderEphemeralX25519KeyPair = createX25519KeyPair();\n  const metadata = constructMetadata(\n    senderEd25519PublicKey,\n    receiverEd25519PublicKey,\n    sequence,\n    senderEphemeralX25519KeyPair.publicKey,\n  );\n\n  ensureMetadataFields(metadata);\n  ensurePrivatePublicFieldsDisjoint<Public, Private>(privateMessage, publicMessage);\n\n  return dangerouslyEncryptAndSignEnvelopeUnvalidated(\n    senderEd25519SecretKey,\n    receiverEd25519PublicKey,\n    metadata,\n    privateMessage,\n    publicMessage,\n    senderEphemeralX25519KeyPair,\n  );\n}\n\nexport function constructMetadata(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  senderEphemeralX25519PublicKey: X25519PublicKey,\n): EnvelopeMetadata {\n  // This is used for SIGNING ONLY!\n  return {\n    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),\n    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),\n    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),\n    sequence,\n    timestampMillis: Date.now(),\n  };\n}\n\nexport function dangerouslyEncryptAndSignEnvelopeUnvalidated<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  metadata: EnvelopeMetadata,\n  privateMessage: Private,\n  publicMessage: Public,\n  senderEphemeralX25519KeyPair: X25519KeyPair,\n): SecuredEnvelopeTransport {\n  const encryptionResult = encryptObject(\n    senderEphemeralX25519KeyPair.secretKey,\n    receiverEd25519PublicKey,\n    privateMessage,\n  );\n  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);\n  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);\n  const serializedPublicMessage = JSON.stringify({ ...publicMessage, _metadata: metadata });\n  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);\n  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);\n  return {\n    encryptedPrivateMessage,\n    messageSignature,\n    serializedPublicMessage,\n  };\n}\n\nfunction combineHashedEnvelopeMessageBytes(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n): Uint8Array {\n  const publicMessageBytesHash = sha3_256(publicMessageBytes);\n  const privateMessageBytesHash = sha3_256(privateMessageBytes);\n  // Concatenate the two hashes\n  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);\n  combinedHash.set(publicMessageBytesHash);\n  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);\n  // Hash and return\n  return sha3_256(combinedHash);\n}\n\nfunction signEnvelope(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  senderEd25519SecretKey: Ed25519SecretKey,\n) {\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, 'SECURED_ENVELOPE');\n  return Hex.fromHexInput(signatureBytes).toString();\n}\n\nexport function verifyEnvelopeSignature(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  messageSignatureInput: string,\n  senderEd25519PublicKey: Ed25519PublicKey,\n) {\n  const messageSignature = new Ed25519Signature(Hex.fromHexInput(messageSignatureInput).toUint8Array());\n  const senderPublicKey = new AptosEd25519PublicKey(senderEd25519PublicKey.key);\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, 'SECURED_ENVELOPE');\n  if (!messageVerified) {\n    throw new EnvelopeMessageMismatchError('Could not verify SecuredEnvelope signature', 'messageSignature');\n  }\n}\n\nexport function decryptEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  message: SecuredEnvelopeTransport,\n): DecryptedEnvelope<Public, Private> {\n  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;\n  const publicMessage = JSON.parse(serializedPublicMessage) as Public & IEnvelopeMetadata;\n\n  // Ensure the private/public message signature matches the expected signature\n  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);\n  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);\n  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);\n\n  // Ensure the public key matches the expected public key\n  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);\n  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;\n  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {\n    throw new EnvelopeMessageMismatchError(\n      'senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey',\n      'senderPublicKey',\n    );\n  }\n\n  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);\n  const senderX25519PublicKey = toKey(senderX25519PublicKeyBytes, KeyTypes.X25519PublicKey);\n  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);\n  const privateMessage = decryptObject<Private>(\n    senderX25519PublicKey,\n    receiverEd25519SecretKey,\n    encryptionResult.secured,\n    encryptionResult.nonce,\n  );\n\n  ensureMetadataFields(publicMessage._metadata);\n  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);\n\n  return {\n    messageSignature,\n    privateMessage,\n    publicMessage,\n  };\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  base64ToBytes,\n  bytesToBase64,\n  deserializePublicKey,\n  deserializeSignature,\n  serializePublicKey,\n  serializeSignature,\n} from '@aptos-connect/wallet-api';\nimport {\n  AccountPublicKey,\n  Deserializer,\n  Ed25519PublicKey as AptosEd25519PublicKey,\n  Ed25519Signature,\n  Hex,\n  PublicKey,\n  Serializer,\n  Signature,\n} from '@aptos-labs/ts-sdk';\nimport { decodeBase64 } from './utils';\n\nexport function serializePublicKeyB64(publicKey: PublicKey) {\n  const serializer = new Serializer();\n  serializePublicKey(serializer, publicKey);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializePublicKeyB64(publicKeyB64: string) {\n  const serializedPublicKey = base64ToBytes(publicKeyB64);\n  const deserializer = new Deserializer(serializedPublicKey);\n  return deserializePublicKey(deserializer) as AccountPublicKey;\n}\n\nexport function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64: string) {\n  return new AptosEd25519PublicKey(decodeBase64(ed25519PublicKeyB64));\n}\n\nexport function serializeSignatureB64(signature: Signature) {\n  const serializer = new Serializer();\n  serializeSignature(serializer, signature);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializeSignatureB64(signatureB64: string) {\n  const serializedSignature = base64ToBytes(signatureB64);\n  const deserializer = new Deserializer(serializedSignature);\n  return deserializeSignature(deserializer);\n}\n\nexport function deserializeEd25519SignatureB64(ed25519SignatureB64: string) {\n  const signatureBytes = Hex.fromHexInput(ed25519SignatureB64).toUint8Array();\n  return new Ed25519Signature(signatureBytes);\n}\n\nexport function publicKeyB64FromEd25519PublicKeyB64(ed25519PublicKeyB64: string) {\n  const publicKey = deserializeEd25519PublicKeyB64(ed25519PublicKeyB64);\n  return serializePublicKeyB64(publicKey);\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n// Adding or removing an account? This will be idempotent, but racy\nimport { Account, AccountPublicKey, PublicKey as AptosPublicKey, Signature } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport { messageHash, signWithEd25519SecretKey } from './encrDecr';\nimport { serializePublicKeyB64, serializeSignatureB64 } from './serialization';\nimport { Ed25519KeyPair, ed25519KeypairFromSecret, Ed25519PublicKey, Ed25519SecretKey, encodeBase64 } from './utils';\n\n// ADD/REMOVE is used for account connections\nexport enum AccountConnectionAction {\n  ADD = 'add',\n  REMOVE = 'remove',\n}\n\n/**\n * When a wallet wants to create a pairing, or add/remove an account from a wallet connection, it must prove that it\n * has the secret key for a given account. To do so it uses an `AccountConnectInfo` object.\n *  1. Once the `AccountConnectInfo` is assembled, it’s JSON serialized to get a `accountInfoSerialized` string.\n *  2. We then domain separate and hash the `accountInfoSerialized` to get the `accountInfoHash`:\n *    `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | SHA3-256(accountInfoSerialized))`\n *  3. To obtain the `signature`, we sign the `accountInfoHash` with the Ed25519 private key of the sender, and hex\n *     encode it.\n *  4. These are assembled into an `AccountConnectInfoSerialized`, ready to be sent in an HTTP request.\n */\n\nexport type BaseAccountConnectInfo = {\n  // The account address\n  accountAddress: string;\n  // either 'add' or 'remove'\n  action: AccountConnectionAction;\n  // A unique identifier for this connection: it is either the walletId or the pairingId\n  // Prevents replay attacks across wallets\n  intentId: string;\n  // Prevents replay attacks across time- these are only valid for 5 minutes\n  timestampMillis: number;\n  // The public key for the encrypted e2e channel, base64\n  transportEd25519PublicKeyB64: string;\n};\n\nexport type Ed25519AccountConnectInfo = BaseAccountConnectInfo & {\n  // The account ed25519 public key, base64\n  ed25519PublicKeyB64: string;\n  publicKeyB64?: undefined;\n};\n\nexport type AnyAccountConnectInfo = BaseAccountConnectInfo & {\n  ed25519PublicKeyB64?: undefined;\n  // The account public key, bcs-serialized and base64-encoded\n  publicKeyB64: string;\n};\n\n// Ensuring compatibility with previous wallet-sdk versions\nexport type AccountConnectInfo = Ed25519AccountConnectInfo | AnyAccountConnectInfo;\n\nexport type Ed25519AccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature: string;\n  signatureB64?: undefined;\n};\n\nexport type AnyAccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature?: undefined;\n  signatureB64: string;\n};\n\nexport type AccountConnectInfoSerialized = Ed25519AccountConnectInfoSerialized | AnyAccountConnectInfoSerialized;\n\nexport type SyncSignCallback = (message: Uint8Array) => Signature;\nexport type AsyncSignCallback = (message: Uint8Array) => Promise<Signature>;\nexport type AnySignCallback = SyncSignCallback | AsyncSignCallback;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKey: Ed25519SecretKey,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: SyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport async function deriveAccountTransportEd25519Keypair(\n  signCallback: AsyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair | Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKeyOrSignCallback: Ed25519SecretKey | AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n) {\n  const publicKeyBytes = publicKey instanceof AptosPublicKey ? publicKey.toUint8Array() : publicKey.key;\n  if (ed25519SecretKeyOrSignCallback instanceof Function) {\n    const seedGeneratorBytes = messageHash(publicKeyBytes, 'TRANSPORT_KEYPAIR');\n    const signature = ed25519SecretKeyOrSignCallback(seedGeneratorBytes);\n    if (signature instanceof Promise<Signature>) {\n      return signature.then((value) => ed25519KeypairFromSecret(value.toUint8Array()));\n    }\n    return ed25519KeypairFromSecret(signature.toUint8Array());\n  }\n\n  const seedBytes = signWithEd25519SecretKey(publicKeyBytes, ed25519SecretKeyOrSignCallback, 'TRANSPORT_KEYPAIR');\n  return ed25519KeypairFromSecret(seedBytes);\n}\n\nexport type CreateSerializedAccountInfoArgs<TSignCallback extends AnySignCallback> = [\n  signCallback: TSignCallback,\n  publicKey: AccountPublicKey,\n  transportEd25519PublicKey: Ed25519PublicKey,\n  action: AccountConnectionAction,\n  intentId: string,\n  accountAddress?: string,\n];\n\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<SyncSignCallback>\n): AccountConnectInfoSerialized;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AsyncSignCallback>\n): Promise<AccountConnectInfoSerialized>;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized>;\n\nexport function createSerializedAccountInfo(\n  ...[\n    signCallback,\n    publicKey,\n    transportEd25519PublicKey,\n    action,\n    intentId,\n    accountAddress,\n  ]: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized> {\n  // TODO: WRITE TESTS FOR THIS!\n\n  // Either the passed in Pk, or the Pk derived from the Sk\n  const authKey = publicKey.authKey();\n\n  // Either the passed in account address, or the one derived from the authKey: (either Pk, or derived from Sk)\n  const finalAccountAddress = accountAddress || authKey.derivedAddress().toString();\n  const publicKeyB64 = serializePublicKeyB64(publicKey);\n\n  const accountInfo: AccountConnectInfo = {\n    accountAddress: finalAccountAddress,\n    action,\n    intentId,\n    publicKeyB64,\n    timestampMillis: Date.now(),\n    transportEd25519PublicKeyB64: encodeBase64(transportEd25519PublicKey.key),\n  };\n  const accountInfoSerialized = JSON.stringify(accountInfo);\n  const accountInfoBytes = new TextEncoder().encode(accountInfoSerialized);\n  const accountInfoHash = sha3_256(accountInfoBytes);\n\n  const signature = signCallback(messageHash(accountInfoHash, 'ACCOUNT_INFO'));\n  if (signature instanceof Promise<Signature>) {\n    return signature.then((value) => ({\n      accountInfoSerialized,\n      signatureB64: serializeSignatureB64(value),\n    }));\n  }\n  return {\n    accountInfoSerialized,\n    signatureB64: serializeSignatureB64(signature),\n  };\n}\n\nexport async function aptosAccountToSerializedInfo(\n  account: Account,\n  intentId: string,\n): Promise<AccountConnectInfoSerialized> {\n  const signCallback = async (data: Uint8Array) => account.sign(data);\n  const transportKey = await deriveAccountTransportEd25519Keypair(signCallback, account.publicKey);\n  return createSerializedAccountInfo(\n    signCallback,\n    account.publicKey,\n    transportKey.publicKey,\n    AccountConnectionAction.ADD,\n    intentId,\n  );\n}\n"],"names":["KeyTypes","nacl","sha3_256","Ed25519Signature","AptosEd25519PublicKey","Hex","AccountConnectionAction"],"mappings":"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"}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/unexpected/node_modules/@identity-connect/api/src/constants.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/api/src/network.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/api/src/types/pairing.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/api/src/types/signingRequest.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/api/src/types/wallet.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_BACKEND_URL = 'https://identityconnect.com';\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum NetworkName {\n  DEVNET = 'devnet',\n  MAINNET = 'mainnet',\n  TESTNET = 'testnet',\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountData } from './account';\nimport { RegisteredDappDataBase } from './dapp';\nimport { ConnectedWalletData } from './wallet';\nimport { DappSpecificWallet } from './dappSpecificWallet';\n\nexport enum PairingStatus {\n  Finalized = 'FINALIZED',\n  Pending = 'PENDING',\n}\n\nexport interface BasePairingData {\n  createdAt: Date;\n  dappEd25519PublicKeyB64: string;\n  dappSpecificWallet?: DappSpecificWallet;\n  dappSpecificWalletId?: string;\n  expiresAt: Date;\n  id: string;\n  maxDappSequenceNumber: number;\n  maxWalletSequenceNumber: number;\n  registeredDapp: RegisteredDappDataBase;\n  registeredDappId: string;\n  status: PairingStatus;\n  updatedAt: Date;\n}\n\nexport interface NewPairingData extends BasePairingData {\n  maxDappSequenceNumber: -1;\n  maxWalletSequenceNumber: -1;\n  status: PairingStatus.Pending;\n}\n\nexport interface BaseFinalizedPairingData extends BasePairingData {\n  account: AccountData;\n  accountId: string;\n  status: PairingStatus.Finalized;\n  walletName: string;\n}\n\nexport interface AnonymousPairingData extends BaseFinalizedPairingData {\n  anonymousWallet: ConnectedWalletData;\n  anonymousWalletId: string;\n}\n\nexport type FinalizedPairingData = BaseFinalizedPairingData | AnonymousPairingData;\nexport type PairingData = NewPairingData | FinalizedPairingData;\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RegisteredDappDataBase } from './dapp';\n\n// region Duplicated from crypto to prevent dependency cycle\n\nexport type SerializedEncryptionResult = {\n  nonceB64: string;\n  securedB64: string;\n};\n\nexport type SecuredEnvelopeTransport = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  serializedPublicMessage: string;\n};\n\n// endregion\n\nexport enum SigningRequestTypes {\n  SIGN_AND_SUBMIT_TRANSACTION = 'SIGN_AND_SUBMIT_TRANSACTION',\n  SIGN_MESSAGE = 'SIGN_MESSAGE',\n  SIGN_TRANSACTION = 'SIGN_TRANSACTION',\n}\n\nexport enum SigningRequestStatus {\n  APPROVED = 'APPROVED',\n  CANCELLED = 'CANCELLED',\n  INVALID = 'INVALID',\n  PENDING = 'PENDING',\n  REJECTED = 'REJECTED',\n}\n\nexport interface SigningRequestData {\n  apiVersion: string;\n  createdAt: Date;\n  id: string;\n  networkName: string | null;\n  pairing: {\n    registeredDapp: RegisteredDappDataBase;\n  };\n  pairingId: string;\n  requestEnvelope: SecuredEnvelopeTransport;\n  requestType: SigningRequestTypes;\n  responseEnvelope?: SecuredEnvelopeTransport;\n  status: SigningRequestStatus;\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { AccountData } from './account';\nimport type { AnonymousPairingData } from './pairing';\nimport { DappSpecificWallet } from './dappSpecificWallet';\n\nexport enum WalletOSEnum {\n  Android = 'android',\n  IdentityConnect = 'ic',\n  Linux = 'linux',\n  Macos = 'osx',\n  Windows = 'win',\n  iOS = 'ios',\n}\n\nexport enum WalletPlatformEnum {\n  BraveExtension = 'brave-extension',\n  ChromeExtension = 'chrome-extension',\n  FirefoxExtension = 'firefox-extension',\n  /// Reserved for IC full custody\n  IcDappWallet = 'ic-dapp-wallet',\n  KiwiExtension = 'kiwi-extension',\n  NativeApp = 'native-app',\n  OperaExtension = 'opera-extension',\n  SafariExtension = 'safari-extension',\n}\n\nexport type WalletOS = `${WalletOSEnum}`;\nexport type WalletPlatform = `${WalletPlatformEnum}`;\n\nexport interface BaseWalletData {\n  createdAt: Date;\n  dappSpecificWallet?: DappSpecificWallet;\n  dappSpecificWalletId?: string;\n  icEd25519PublicKeyB64: string;\n  id: string;\n  updatedAt: Date;\n}\n\nexport interface NewWalletData extends BaseWalletData {\n  walletEd25519PublicKeyB64: null;\n}\n\nexport interface BaseConnectedWalletData extends BaseWalletData {\n  accounts: AccountData[];\n  deviceIdentifier: string;\n  platform: WalletPlatform;\n  platformOS: WalletOS;\n  userSubmittedAlias?: string;\n  walletEd25519PublicKeyB64: string;\n  walletName: string;\n}\n\nexport interface AuthenticatedWalletData extends BaseConnectedWalletData {\n  anonymousPairing: null;\n  user: { id: string; username: string };\n  userId: string;\n}\n\nexport interface AnonymousWalletData extends BaseConnectedWalletData {\n  anonymousPairing: AnonymousPairingData;\n  userId: null;\n}\n\nexport type ConnectedWalletData = AuthenticatedWalletData | AnonymousWalletData;\n\nexport type WalletData = NewWalletData | ConnectedWalletData;\n"],"names":["NetworkName","PairingStatus","SigningRequestTypes","SigningRequestStatus","WalletOSEnum","WalletPlatformEnum"],"mappings":";;;;;;;;;;AAGO,IAAM,sBAAsB;;ACA5B,IAAK,cAAL,aAAA,GAAA,CAAA,CAAKA;IACVA,YAAAA,CAAA,SAAA,GAAS;IACTA,YAAAA,CAAA,UAAA,GAAU;IACVA,YAAAA,CAAA,UAAA,GAAU;IAHA,OAAAA;AAAA,CAAA,EAAA,eAAA,CAAA;;ACKL,IAAK,gBAAL,aAAA,GAAA,CAAA,CAAKC;IACVA,cAAAA,CAAA,YAAA,GAAY;IACZA,cAAAA,CAAA,UAAA,GAAU;IAFA,OAAAA;AAAA,CAAA,EAAA,iBAAA,CAAA;;ACYL,IAAK,sBAAL,aAAA,GAAA,CAAA,CAAKC;IACVA,oBAAAA,CAAA,8BAAA,GAA8B;IAC9BA,oBAAAA,CAAA,eAAA,GAAe;IACfA,oBAAAA,CAAA,mBAAA,GAAmB;IAHT,OAAAA;AAAA,CAAA,EAAA,uBAAA,CAAA;AAML,IAAK,uBAAL,aAAA,GAAA,CAAA,CAAKC;IACVA,qBAAAA,CAAA,WAAA,GAAW;IACXA,qBAAAA,CAAA,YAAA,GAAY;IACZA,qBAAAA,CAAA,UAAA,GAAU;IACVA,qBAAAA,CAAA,UAAA,GAAU;IACVA,qBAAAA,CAAA,WAAA,GAAW;IALD,OAAAA;AAAA,CAAA,EAAA,wBAAA,CAAA;;ACnBL,IAAK,eAAL,aAAA,GAAA,CAAA,CAAKC;IACVA,aAAAA,CAAA,UAAA,GAAU;IACVA,aAAAA,CAAA,kBAAA,GAAkB;IAClBA,aAAAA,CAAA,QAAA,GAAQ;IACRA,aAAAA,CAAA,QAAA,GAAQ;IACRA,aAAAA,CAAA,UAAA,GAAU;IACVA,aAAAA,CAAA,MAAA,GAAM;IANI,OAAAA;AAAA,CAAA,EAAA,gBAAA,CAAA;AASL,IAAK,qBAAL,aAAA,GAAA,CAAA,CAAKC;IACVA,mBAAAA,CAAA,iBAAA,GAAiB;IACjBA,mBAAAA,CAAA,kBAAA,GAAkB;IAClBA,mBAAAA,CAAA,mBAAA,GAAmB;IAEnBA,mBAAAA,CAAA,eAAA,GAAe;IACfA,mBAAAA,CAAA,gBAAA,GAAgB;IAChBA,mBAAAA,CAAA,YAAA,GAAY;IACZA,mBAAAA,CAAA,iBAAA,GAAiB;IACjBA,mBAAAA,CAAA,kBAAA,GAAkB;IATR,OAAAA;AAAA,CAAA,EAAA,sBAAA,CAAA"}},
    {"offset": {"line": 512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 517, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/serialization/bcsSerialization.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/serialization/jsonPayload.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/serialization/error.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/serialization/rawTxn.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/serialization/signAndSubmitTransactionRequestArgs.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/serialization/signTransactionRequestArgs.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/serialization/signTransactionResponseArgs.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/wallet-api/src/utils/makeFullMessage.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Hex, Serializable as BcsSerializableV2 } from '@aptos-labs/ts-sdk';\nimport { BCS } from 'aptos';\n\nexport type BcsSerializableV1 = { serialize(serializer: BCS.Serializer): void };\nexport type BcsDeserializableV1Class<T extends BcsSerializableV1> = {\n  deserialize(deserializer: BCS.Deserializer): T;\n};\nexport type BcsDeserializableV2Class<T extends BcsSerializableV2> = {\n  deserialize(deserializer: Deserializer): T;\n};\n\nfunction isBcsSerializableV1(value: any): value is BcsSerializableV1 {\n  return (value as BcsSerializableV1)?.serialize !== undefined;\n}\n\nfunction isBcsSerializableV2(value: any): value is BcsSerializableV2 {\n  return (\n    (value as BcsSerializableV2)?.serialize !== undefined &&\n    (value as BcsSerializableV2)?.bcsToBytes !== undefined &&\n    (value as BcsSerializableV2)?.bcsToHex !== undefined\n  );\n}\n\n/**\n * Check if a value is BCS serializable\n */\nexport function isBcsSerializable(value: any): value is BcsSerializableV1 | BcsSerializableV2 {\n  return isBcsSerializableV1(value) || isBcsSerializableV2(value);\n}\n\nexport function bcsSerialize(serializable: BcsSerializableV1 | BcsSerializableV2) {\n  if (isBcsSerializableV2(serializable)) {\n    return serializable.bcsToHex().toString();\n  }\n  const serializedValueBytes = BCS.bcsToBytes(serializable);\n  return Hex.fromHexInput(serializedValueBytes).toString();\n}\n\nexport function bcsDeserialize<T extends BcsSerializableV2>(\n  deserializableClass: BcsDeserializableV2Class<T>,\n  serializedValue: string,\n) {\n  const serializedValueBytes = Hex.fromHexString(serializedValue).toUint8Array();\n  const deserializer = new Deserializer(serializedValueBytes);\n  return deserializableClass.deserialize(deserializer);\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Hex } from '@aptos-labs/ts-sdk';\nimport type { EntryFunctionPayloadResponse } from '@aptos-labs/ts-sdk';\nimport type { EntryFunctionJsonTransactionPayload, JsonTransactionPayload } from '../types';\nimport { UnexpectedValueError } from './error';\n\ninterface SerializedUint8ArrayArg {\n  type: 'Uint8Array';\n  value: string;\n}\n\nfunction isSerializedUint8Array(arg: any): arg is SerializedUint8ArrayArg {\n  return arg?.type === 'Uint8Array' && typeof arg?.value === 'string';\n}\n\nfunction serializeEntryFunctionArg(arg: any): any {\n  if (arg instanceof Uint8Array) {\n    return {\n      type: 'Uint8Array',\n      value: Hex.fromHexInput(arg).toString(),\n    };\n  }\n  if (Array.isArray(arg)) {\n    return arg.map(serializeEntryFunctionArg);\n  }\n  return arg;\n}\n\nfunction deserializeEntryFunctionArg(arg: any): any {\n  if (isSerializedUint8Array(arg)) {\n    return Hex.fromHexInput(arg.value).toUint8Array();\n  }\n  if (Array.isArray(arg)) {\n    return arg.map(deserializeEntryFunctionArg);\n  }\n  return arg;\n}\n\nfunction serializeEntryFunctionPayload(payload: EntryFunctionPayloadResponse): EntryFunctionJsonTransactionPayload {\n  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);\n  return {\n    ...payload,\n    arguments: normalizedArgs,\n    type: 'entry_function_payload',\n  };\n}\n\nfunction deserializeEntryFunctionPayload(payload: EntryFunctionPayloadResponse): EntryFunctionJsonTransactionPayload {\n  const deserializedArgs = payload.arguments.map(deserializeEntryFunctionArg);\n  return {\n    ...payload,\n    arguments: deserializedArgs,\n    type: 'entry_function_payload',\n  };\n}\n\nexport function serializeJsonTransactionPayload(payload: JsonTransactionPayload): JsonTransactionPayload {\n  if (payload.type === 'entry_function_payload' || payload.type === undefined) {\n    return serializeEntryFunctionPayload(payload);\n  }\n  if (payload.type === 'multisig_payload') {\n    const innerPayload =\n      payload.transaction_payload !== undefined\n        ? serializeEntryFunctionPayload(payload.transaction_payload)\n        : undefined;\n    return { ...payload, transaction_payload: innerPayload };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeJsonTransactionPayload(payload: JsonTransactionPayload): JsonTransactionPayload {\n  if (payload.type === 'entry_function_payload' || payload.type === undefined) {\n    return deserializeEntryFunctionPayload(payload);\n  }\n  if (payload.type === 'multisig_payload') {\n    const innerPayload =\n      payload.transaction_payload !== undefined\n        ? deserializeEntryFunctionPayload(payload.transaction_payload)\n        : undefined;\n    return { ...payload, transaction_payload: innerPayload };\n  }\n  throw new UnexpectedValueError();\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport class UnexpectedValueError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = 'UnexpectedValueError';\n    Object.setPrototypeOf(this, UnexpectedValueError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  RawTransaction,\n  RawTransactionWithData,\n} from '@aptos-labs/ts-sdk';\nimport { TxnBuilderTypes } from 'aptos';\nimport { bcsDeserialize, bcsSerialize } from './bcsSerialization';\nimport { UnexpectedValueError } from './error';\n\nexport type SerializableRawTransaction = RawTransaction | FeePayerRawTransaction | MultiAgentRawTransaction;\n\nexport type SerializableRawTransactionV1 =\n  | TxnBuilderTypes.RawTransaction\n  | TxnBuilderTypes.FeePayerRawTransaction\n  | TxnBuilderTypes.MultiAgentRawTransaction;\n\nexport interface SerializedSimpleRawTransaction {\n  type: 'raw_txn';\n  value: string;\n}\n\nexport interface SerializedFeePayerRawTransaction {\n  type: 'fee_payer_raw_txn';\n  value: string;\n}\n\nexport interface SerializedMultiAgentRawTransaction {\n  type: 'multi_agent_raw_txn';\n  value: string;\n}\n\nexport type SerializedRawTransaction =\n  | SerializedSimpleRawTransaction\n  | SerializedFeePayerRawTransaction\n  | SerializedMultiAgentRawTransaction;\n\nexport function serializeRawTransaction(\n  rawTxn: RawTransaction | TxnBuilderTypes.RawTransaction,\n): SerializedSimpleRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: FeePayerRawTransaction | TxnBuilderTypes.FeePayerRawTransaction,\n): SerializedFeePayerRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: MultiAgentRawTransaction | TxnBuilderTypes.MultiAgentRawTransaction,\n): SerializedMultiAgentRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: SerializableRawTransaction | SerializableRawTransactionV1,\n): SerializedRawTransaction;\n\nexport function serializeRawTransaction(\n  rawTxn: SerializableRawTransaction | SerializableRawTransactionV1,\n): SerializedRawTransaction {\n  const value = bcsSerialize(rawTxn);\n  if ('fee_payer_address' in rawTxn) {\n    return { type: 'fee_payer_raw_txn', value };\n  }\n  if ('secondary_signer_addresses' in rawTxn) {\n    return { type: 'multi_agent_raw_txn', value };\n  }\n  if ('chain_id' in rawTxn) {\n    return { type: 'raw_txn', value };\n  }\n  throw new UnexpectedValueError('Invalid raw transaction type');\n}\n\nexport function deserializeRawTransaction(serialized: SerializedSimpleRawTransaction): RawTransaction;\nexport function deserializeRawTransaction(serialized: SerializedFeePayerRawTransaction): FeePayerRawTransaction;\nexport function deserializeRawTransaction(serialized: SerializedMultiAgentRawTransaction): MultiAgentRawTransaction;\nexport function deserializeRawTransaction(serialized: SerializedRawTransaction): SerializableRawTransaction;\n\nexport function deserializeRawTransaction(serialized: SerializedRawTransaction): SerializableRawTransaction {\n  switch (serialized.type) {\n    case 'raw_txn':\n      return bcsDeserialize(RawTransaction, serialized.value);\n    case 'fee_payer_raw_txn':\n      return bcsDeserialize(RawTransactionWithData, serialized.value) as FeePayerRawTransaction;\n    case 'multi_agent_raw_txn':\n      return bcsDeserialize(RawTransactionWithData, serialized.value) as MultiAgentRawTransaction;\n    default:\n      throw new UnexpectedValueError('Invalid raw transaction type');\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAuthenticator, TransactionPayload } from '@aptos-labs/ts-sdk';\nimport type {\n  SignAndSubmitTransactionRequestArgs,\n  SignAndSubmitTransactionRequestV1Args,\n  SignAndSubmitTransactionWithFeePayerRawTxnRequestArgs,\n  SignAndSubmitTransactionWithPayloadRequestArgs,\n  SignAndSubmitTransactionWithRawTxnRequestArgs,\n} from '../types';\nimport { JsonTransactionPayload, TransactionOptions } from '../types';\nimport { bcsDeserialize, bcsSerialize, isBcsSerializable } from './bcsSerialization';\n\nimport { UnexpectedValueError } from './error';\nimport { deserializeJsonTransactionPayload, serializeJsonTransactionPayload } from './jsonPayload';\nimport {\n  deserializeRawTransaction,\n  type SerializedFeePayerRawTransaction,\n  type SerializedSimpleRawTransaction,\n  serializeRawTransaction,\n} from './rawTxn';\n\nexport interface SerializedSignAndSubmitTransactionWithPayloadRequestArgs {\n  options?: TransactionOptions;\n  payload: JsonTransactionPayload | string;\n}\n\nexport interface SerializedSignAndSubmitTransactionWithRawTxnRequestArgs {\n  rawTxn: SerializedSimpleRawTransaction;\n}\n\nexport interface SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs {\n  feePayerAuthenticator: string;\n  rawTxn: SerializedFeePayerRawTransaction;\n}\n\nexport type SerializedSignAndSubmitTransactionRequestArgs =\n  | SerializedSignAndSubmitTransactionWithPayloadRequestArgs\n  | SerializedSignAndSubmitTransactionWithRawTxnRequestArgs\n  | SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs;\n\nexport function serializeSignAndSubmitTransactionRequestArgs(\n  args: SignAndSubmitTransactionRequestArgs | SignAndSubmitTransactionRequestV1Args,\n): SerializedSignAndSubmitTransactionRequestArgs {\n  if ('payload' in args) {\n    const serializedPayload = isBcsSerializable(args.payload)\n      ? bcsSerialize(args.payload)\n      : serializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload: serializedPayload };\n  }\n  if ('feePayerAuthenticator' in args) {\n    return {\n      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),\n      rawTxn: serializeRawTransaction(args.rawTxn),\n    };\n  }\n  if ('rawTxn' in args) {\n    return { rawTxn: serializeRawTransaction(args.rawTxn) };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithPayloadRequestArgs,\n): SignAndSubmitTransactionWithPayloadRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithRawTxnRequestArgs,\n): SignAndSubmitTransactionWithRawTxnRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs,\n): SignAndSubmitTransactionWithFeePayerRawTxnRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionRequestArgs,\n): SignAndSubmitTransactionRequestArgs;\n\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionRequestArgs,\n): SignAndSubmitTransactionRequestArgs {\n  if ('payload' in args) {\n    const payload =\n      typeof args.payload === 'string'\n        ? bcsDeserialize(TransactionPayload, args.payload)\n        : deserializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload };\n  }\n  if ('feePayerAuthenticator' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    const feePayerAuthenticator = bcsDeserialize(AccountAuthenticator, args.feePayerAuthenticator);\n    return { feePayerAuthenticator, rawTxn: deserializedRawTxn };\n  }\n  if ('rawTxn' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    return { rawTxn: deserializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TransactionPayload } from '@aptos-labs/ts-sdk';\nimport type {\n  JsonTransactionPayload,\n  SignTransactionRequestArgs,\n  SignTransactionRequestV1Args,\n  SignTransactionWithPayloadRequestArgs,\n  SignTransactionWithRawTxnRequestArgs,\n  TransactionOptions,\n} from '../types';\nimport { bcsDeserialize, bcsSerialize, isBcsSerializable } from './bcsSerialization';\nimport { UnexpectedValueError } from './error';\nimport { deserializeJsonTransactionPayload, serializeJsonTransactionPayload } from './jsonPayload';\nimport type { SerializedRawTransaction } from './rawTxn';\nimport { deserializeRawTransaction, serializeRawTransaction } from './rawTxn';\n\nexport interface SerializedSignTransactionWithPayloadRequestArgs {\n  options?: TransactionOptions;\n  payload: JsonTransactionPayload | string;\n}\n\nexport interface SerializedSignTransactionWithRawTxnRequestArgs {\n  rawTxn: SerializedRawTransaction;\n}\n\nexport type SerializedSignTransactionRequestArgs =\n  | SerializedSignTransactionWithPayloadRequestArgs\n  | SerializedSignTransactionWithRawTxnRequestArgs;\n\nexport function serializeSignTransactionRequestArgs(\n  args: SignTransactionRequestArgs | SignTransactionRequestV1Args,\n): SerializedSignTransactionRequestArgs {\n  if ('payload' in args) {\n    const serializedPayload = isBcsSerializable(args.payload)\n      ? bcsSerialize(args.payload)\n      : serializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload: serializedPayload };\n  }\n  if ('rawTxn' in args) {\n    const serializedRawTxn = serializeRawTransaction(args.rawTxn);\n    return { rawTxn: serializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionWithPayloadRequestArgs,\n): SignTransactionWithPayloadRequestArgs;\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionWithRawTxnRequestArgs,\n): SignTransactionWithRawTxnRequestArgs;\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionRequestArgs,\n): SignTransactionRequestArgs;\n\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionRequestArgs,\n): SignTransactionRequestArgs {\n  if ('payload' in args) {\n    const payload =\n      typeof args.payload === 'string'\n        ? bcsDeserialize(TransactionPayload, args.payload)\n        : deserializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload };\n  }\n  if ('rawTxn' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    return { rawTxn: deserializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAuthenticator, RawTransaction } from '@aptos-labs/ts-sdk';\nimport type { SignTransactionResponseArgs } from '../types';\nimport { bcsDeserialize, bcsSerialize } from './bcsSerialization';\n\nexport interface SerializedSignTransactionWithPayloadResponseArgs {\n  accountAuthenticator: string;\n  rawTxn: string;\n}\n\nexport interface SerializedSignTransactionWithRawTxnResponseArgs {\n  accountAuthenticator: string;\n}\n\nexport type SerializedSignTransactionResponseArgs =\n  | SerializedSignTransactionWithPayloadResponseArgs\n  | SerializedSignTransactionWithRawTxnResponseArgs;\n\nexport function serializeSignTransactionResponseArgs(\n  args: SignTransactionResponseArgs,\n): SerializedSignTransactionResponseArgs {\n  const accountAuthenticator = bcsSerialize(args.accountAuthenticator);\n  if ('rawTxn' in args) {\n    const rawTxn = bcsSerialize(args.rawTxn);\n    return { accountAuthenticator, rawTxn };\n  }\n  return { accountAuthenticator };\n}\n\nexport function deserializeSignTransactionResponseArgs(\n  args: SerializedSignTransactionResponseArgs,\n): SignTransactionResponseArgs {\n  const accountAuthenticator = bcsDeserialize(AccountAuthenticator, args.accountAuthenticator);\n  if ('rawTxn' in args) {\n    const rawTxn = bcsDeserialize(RawTransaction, args.rawTxn);\n    return { accountAuthenticator, rawTxn };\n  }\n  return { accountAuthenticator };\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { FullMessageFlags, FullMessageParams, FullMessageResult } from '../types';\n\nconst prefix = 'APTOS';\n\nexport function makeFullMessage(params: FullMessageParams, flags: FullMessageFlags): FullMessageResult {\n  let fullMessage = prefix;\n  if (flags.address) {\n    fullMessage += `\\naddress: ${params.address}`;\n  }\n  if (flags.application) {\n    fullMessage += `\\napplication: ${params.application}`;\n  }\n  if (flags.chainId) {\n    fullMessage += `\\nchainId: ${params.chainId}`;\n  }\n\n  fullMessage += `\\nmessage: ${params.message}`;\n  fullMessage += `\\nnonce: ${params.nonce}`;\n\n  return {\n    fullMessage,\n    prefix,\n  };\n}\n"],"names":["Hex","TransactionPayload","AccountAuthenticator","RawTransaction"],"mappings":"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"}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 815, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/ACDappClient.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/constants.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/PairingClient.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/errors.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/state.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/utils.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/ICDappClient.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/prompt.ts","/turbopack/[project]/unexpected/node_modules/@identity-connect/dapp-sdk/src/KeylessClient.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  chainIdToNetwork,\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  makeUserApproval,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport {\n  AccountAddress,\n  AccountAddressInput,\n  AnySignature,\n  AnyTransactionPayloadInstance,\n  AptosConfig,\n  Deserializer,\n  Ed25519Signature,\n  FeePayerRawTransaction,\n  generateRawTransaction,\n  generateTransactionPayload,\n  generateTransactionPayloadWithABI,\n  Hex,\n} from '@aptos-labs/ts-sdk';\nimport { NetworkName } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { SignAndSubmitTransactionRequestArgs } from '@identity-connect/wallet-api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { ACPairingClient } from './PairingClient';\n\nexport interface WithSignerAddress {\n  signerAddress: AccountAddress;\n}\n\nexport interface ACDappClientConfig {\n  backendBaseURL?: string;\n  dappId?: string;\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n}\n\nexport class ACDappClient {\n  private readonly defaultNetworkName: NetworkName;\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  private readonly dappId?: string;\n  private readonly pairingClient: ACPairingClient;\n\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n  }: ACDappClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL);\n\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL,\n      },\n      defaultNetworkName,\n    });\n  }\n\n  // region Public API\n\n  private async getKeylessAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  private async getIcAccounts() {\n    return this.pairingClient.getConnectedAccounts() ?? [];\n  }\n\n  private async isIcAccount(address: AccountAddressInput) {\n    const icAccounts = await this.getIcAccounts();\n    return icAccounts.find((account) => account.address.equals(AccountAddress.from(address))) !== undefined;\n  }\n\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n\n  async disconnect(address: AccountAddressInput) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = AccountAddress.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n\n  async connect() {\n    const dappKeypair = createEd25519KeyPair();\n\n    const requestArgs = {\n      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n    };\n\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n\n    if (response.args.status === 'approved') {\n      const { account, pairing } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return makeUserApproval({ account });\n    }\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const { chainId } = args;\n      const network = chainIdToNetwork(chainId) as string;\n\n      let message: string;\n      let nonce: string;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (err) {\n        throw new Error('Only UTF-8 encoded text is supported when using IC');\n      }\n\n      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(\n        signerAddress.toString(),\n        {\n          address: true,\n          application: true,\n          chainId: true,\n          message,\n          nonce,\n        },\n        { networkName: network as NetworkName },\n      );\n\n      const signatureBytes = Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature =\n        signatureBytes.length === Ed25519Signature.LENGTH\n          ? new Ed25519Signature(signatureBytes)\n          : AnySignature.deserialize(new Deserializer(signatureBytes));\n      return makeUserApproval<SignMessageResponse.ApprovalArgs>({\n        fullMessage,\n        signature,\n      });\n    }\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: (SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction) & WithSignerAddress,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber,\n      } = normalizedArgs;\n\n      if (feePayer !== undefined) {\n        throw new Error('Sponsored transaction not currently supported');\n      }\n\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error('Multi-agent transactions not currently supported');\n      }\n\n      if (!('bcsToBytes' in payload)) {\n        throw new Error('Payload input format is only supported with Keyless accounts.');\n      }\n\n      const responseArgs = await this.pairingClient.signTransaction(\n        signerAddress.toString(),\n        {\n          options: {\n            expirationSecondsFromNow,\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n            sender: sender?.address.toString(),\n            sequenceNumber: sequenceNumber !== undefined ? Number(sequenceNumber) : undefined,\n          },\n          payload,\n        },\n        {\n          networkName: network as NetworkName | undefined,\n        },\n      );\n      return makeUserApproval({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn,\n      });\n    }\n\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;\n      const aptosConfig = new AptosConfig({ network });\n\n      // Generate payload from input if needed\n      let payload: AnyTransactionPayloadInstance;\n      if ('bcsToBytes' in args.payload) {\n        payload = args.payload as AnyTransactionPayloadInstance;\n      } else if ('bytecode' in args.payload) {\n        payload = await generateTransactionPayload(args.payload);\n      } else {\n        payload =\n          args.payload.abi !== undefined\n            ? generateTransactionPayloadWithABI({ ...args.payload, abi: args.payload.abi })\n            : await generateTransactionPayload({ aptosConfig, ...args.payload });\n      }\n\n      let convertedArgs: SignAndSubmitTransactionRequestArgs;\n      if (feePayer !== undefined) {\n        const rawTxn = await generateRawTransaction({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n          sender: signerAddress,\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new FeePayerRawTransaction(rawTxn, [], feePayer.address),\n        };\n      } else {\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n        };\n      }\n\n      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {\n        networkName: network as NetworkName | undefined,\n      });\n      return makeUserApproval<SignAndSubmitTransactionResponse.ApprovalArgs>({ txnHash: hash });\n    }\n\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_FRONTEND_URL = 'https://aptosconnect.app';\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-await-in-loop */\n\nimport { AccountInfo } from '@aptos-connect/wallet-api';\nimport { AccountAddress } from '@aptos-labs/ts-sdk';\nimport {\n  CancelSigningRequestSerializedResponse,\n  CreateSigningRequestSerializedResponse,\n  FinalizedPairingData,\n  GetPairingSerializedResponse,\n  GetSigningRequestSerializedResponse,\n  NetworkName,\n  SerializedDate,\n  SigningRequestData,\n  SigningRequestStatus,\n  SigningRequestTypes,\n} from '@identity-connect/api';\nimport {\n  decodeBase64,\n  decryptEnvelope,\n  deserializeEd25519PublicKeyB64,\n  deserializePublicKeyB64,\n  Ed25519KeyPair,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  encryptAndSignEnvelope,\n  KeyTypes,\n  toKey,\n} from '@identity-connect/crypto';\nimport {\n  deserializeSignTransactionResponseArgs,\n  type SerializedSignAndSubmitTransactionRequestArgs,\n  type SerializedSignTransactionRequestArgs,\n  type SerializedSignTransactionResponseArgs,\n  serializeSignAndSubmitTransactionRequestArgs,\n  serializeSignTransactionRequestArgs,\n  type SignAndSubmitTransactionRequestArgs,\n  type SignAndSubmitTransactionResponseArgs,\n  SignMessageRequestArgs,\n  SignMessageResponseArgs,\n  type SignTransactionRequestArgs,\n  type SignTransactionResponseArgs,\n  type SignTransactionWithPayloadRequestArgs,\n  type SignTransactionWithPayloadResponseArgs,\n  type SignTransactionWithRawTxnRequestArgs,\n  type SignTransactionWithRawTxnResponseArgs,\n} from '@identity-connect/wallet-api';\nimport axios, { AxiosError, AxiosInstance, CreateAxiosDefaults, isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { PairingExpiredError, SignatureRequestError } from './errors';\nimport { DappPairingData, DappStateAccessors, windowStateAccessors } from './state';\nimport { CancelToken } from './types';\nimport { validateSignAndSubmitTransactionResponse, validateSignMessageResponse } from './utils';\n\nconst API_VERSION = '0.2.0' as const;\nconst SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nconst SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\n\nasync function waitFor(milliseconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n}\n\nasync function withRetries<Response>(\n  requestFn: () => Promise<Response>,\n  onError: (err: any) => void,\n  retries: number = 1,\n) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\n\nexport interface SignRequestOptions {\n  cancelToken?: CancelToken;\n  networkName?: NetworkName;\n}\n\nexport type OnDisconnectListener = (address: string) => void;\nexport type OnDisconnectListenerCleanup = () => void;\n\nexport interface ACPairingClientConfig {\n  accessors?: DappStateAccessors;\n  axiosConfig?: CreateAxiosDefaults;\n  defaultNetworkName?: NetworkName;\n}\n\nexport class ACPairingClient {\n  protected readonly accessors: DappStateAccessors;\n  private readonly defaultNetworkName: NetworkName;\n  protected readonly axiosInstance: AxiosInstance;\n  private readonly initPromise?: Promise<void>;\n\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = NetworkName.MAINNET,\n  }: ACPairingClientConfig = {}) {\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios.create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig,\n    });\n\n    const isClientSideRendering = typeof window !== 'undefined';\n    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : undefined;\n  }\n\n  private async getPairing(id: string) {\n    const response = await this.axiosInstance.get<GetPairingSerializedResponse>(`v1/pairing/${id}/`);\n    return response.data.data.pairing;\n  }\n\n  private async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === undefined) {\n      return;\n    }\n\n    try {\n      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id,\n      });\n    } catch (err) {\n      await this.accessors.update(firstPairing.accountAddress, undefined);\n    }\n  }\n\n  private async createSigningRequest<TRequestBody>(\n    pairing: DappPairingData,\n    type: string,\n    networkName: NetworkName,\n    requestBody: TRequestBody,\n  ) {\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(\n      async () => {\n        const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          sequenceNumber,\n          { apiVersion: API_VERSION, networkName, requestType: type },\n          requestBody,\n        );\n\n        const response = await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n          `v1/pairing/${pairing.pairingId}/signing-request/`,\n          requestEnvelope,\n        );\n\n        await this.accessors.update(pairing.accountAddress, {\n          ...pairing,\n          currSequenceNumber: sequenceNumber,\n        });\n\n        return response.data.data.signingRequest;\n      },\n      (err) => {\n        if (isAxiosError(err)) {\n          const errorMessage: string = err.response?.data?.message;\n          const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];\n          if (expectedSequenceNumber !== undefined) {\n            sequenceNumber = Number(expectedSequenceNumber);\n            return;\n          }\n        }\n        throw err;\n      },\n    );\n  }\n\n  private async getSigningRequest(id: string) {\n    const response = await this.axiosInstance.get<GetSigningRequestSerializedResponse | undefined>(\n      `v1/signing-request/${id}/`,\n      {\n        validateStatus: (status) => status === 200 || status === 404,\n      },\n    );\n    return response.data?.data?.signingRequest;\n  }\n\n  protected async deletePairing(pairingId: string, secretKey: Ed25519SecretKey, publicKey: Ed25519PublicKey) {\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      secretKey,\n      publicKey,\n      publicKey,\n      0, // ignored\n      {},\n      {},\n    );\n\n    await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n      `v1/pairing/${pairingId}/delete/`,\n      requestEnvelope,\n      { validateStatus: (status) => status === 204 || status === 404 },\n    );\n  }\n\n  async cancelSigningRequest(pairing: DappPairingData, id: string) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      sequenceNumber + 1,\n      {},\n      {},\n    );\n\n    const response = await this.axiosInstance.patch<CancelSigningRequestSerializedResponse>(\n      `v1/signing-request/${id}/cancel/`,\n      requestEnvelope,\n    );\n\n    // TODO: auto-sync sequence number on error\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1,\n    });\n\n    return response.data.data.signingRequest;\n  }\n\n  private async signRequest<TRequestBody, TResponseBody>(\n    address: string,\n    type: SigningRequestTypes,\n    requestBody: TRequestBody,\n    { cancelToken, networkName }: SignRequestOptions = {},\n  ) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The requested account is not paired');\n    }\n\n    let signingRequest: SerializedDate<SigningRequestData>;\n\n    try {\n      signingRequest = await this.createSigningRequest<TRequestBody>(\n        pairing,\n        type,\n        networkName || this.defaultNetworkName,\n        requestBody,\n      );\n\n      while (signingRequest.status === 'PENDING') {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          // TODO: send cancel request\n          signingRequest.status = SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest = (await this.getSigningRequest(signingRequest.id)) ?? signingRequest;\n      }\n    } catch (err) {\n      if (isAxiosError(err) && err.code === '404') {\n        await this.accessors.update(address, undefined);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n\n    if (signingRequest.status !== 'APPROVED') {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n\n    const decrypted = decryptEnvelope<{}, TResponseBody & {}>(\n      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),\n      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),\n      signingRequest.responseEnvelope!,\n    );\n    return decrypted.privateMessage;\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing({ publicKey, secretKey }: Ed25519KeyPair, finalizedPairing: SerializedDate<FinalizedPairingData>) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? undefined,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),\n      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id,\n    });\n  }\n\n  async disconnect(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The specified account is not paired');\n    }\n\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(\n      pairing.pairingId,\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n    );\n    await this.accessors.update(address, undefined);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n\n  async signMessage(address: string, args: SignMessageRequestArgs, options?: SignRequestOptions) {\n    const response = await this.signRequest<SignMessageRequestArgs, SignMessageResponseArgs>(\n      address,\n      SigningRequestTypes.SIGN_MESSAGE,\n      args,\n      options,\n    );\n    validateSignMessageResponse(response);\n    return response;\n  }\n\n  // region signTransaction\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithPayloadRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithPayloadResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithRawTxnRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithRawTxnResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);\n    const serializedResponseArgs = await this.signRequest<\n      SerializedSignTransactionRequestArgs,\n      SerializedSignTransactionResponseArgs\n    >(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);\n    return deserializeSignTransactionResponseArgs(serializedResponseArgs);\n  }\n\n  // endregion\n\n  async signAndSubmitTransaction(\n    address: string,\n    args: SignAndSubmitTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignAndSubmitTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);\n    try {\n      const responseArgs = await this.signRequest<\n        SerializedSignAndSubmitTransactionRequestArgs,\n        SignAndSubmitTransactionResponseArgs\n      >(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map<AccountInfo>(\n      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({\n        address: AccountAddress.from(accountAddress),\n        publicKey:\n          accountPublicKeyB64 !== undefined\n            ? deserializePublicKeyB64(accountPublicKeyB64)\n            : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64),\n      }),\n    );\n  }\n\n  // endregion\n\n  private readonly onDisconnectListeners = new Set<OnDisconnectListener>();\n\n  onDisconnect(listener: OnDisconnectListener): OnDisconnectListenerCleanup {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SigningRequestStatus } from '@identity-connect/api';\n\nexport class SignatureRequestError extends Error {\n  constructor(status: SigningRequestStatus) {\n    super(status);\n    this.name = 'SignatureRequestError';\n    Object.setPrototypeOf(this, SignatureRequestError.prototype);\n  }\n}\n\nexport class UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields: string[]) {\n    const message = `Missing the following fields: ${missingFields.join(', ')}`;\n    super(message);\n    this.name = 'UnexpectedSignatureResponseError';\n    Object.setPrototypeOf(this, UnexpectedSignatureResponseError.prototype);\n  }\n}\n\nexport class PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = 'PairingExpiredError';\n    Object.setPrototypeOf(this, PairingExpiredError.prototype);\n  }\n}\n\nexport class UnregisteredDappError extends Error {\n  constructor() {\n    super('Dapp ID is invalid or not associated with a registered Dapp.');\n    this.name = 'UnregisteredDappError';\n    Object.setPrototypeOf(this, UnregisteredDappError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface BaseDappPairingData {\n  accountAddress: string;\n  accountAlias?: string;\n  accountTransportEd25519PublicKeyB64: string;\n  currSequenceNumber: number;\n  dappEd25519PublicKeyB64: string;\n  dappEd25519SecretKeyB64: string;\n  dappWalletId?: string;\n  pairingId: string;\n}\n\n// Keeping this temporarily for backward compatibility\nexport interface PrevDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64: string;\n  accountPublicKeyB64?: undefined;\n}\n\nexport interface CurrDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64?: undefined;\n  accountPublicKeyB64: string;\n}\n\nexport type DappPairingData = PrevDappPairingData | CurrDappPairingData;\n\nexport type DappPairingDataMap = { [address: string]: DappPairingData };\n\nexport interface DappStateAccessors {\n  get: (address: string) => Promise<DappPairingData | undefined>;\n  getAll: () => Promise<DappPairingDataMap>;\n  update: (address: string, pairing?: DappPairingData) => Promise<void>;\n}\n\nexport const DAPP_PAIRINGS_WINDOW_STORAGE_KEY = 'icDappPairings';\n\n/**\n * Default implementation of DappStateAccessors that uses the Window localStorage API.\n * This should work for most dapps.\n */\nexport const windowStateAccessors: DappStateAccessors = {\n  async get(address: string) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);\n    return serialized ? (JSON.parse(serialized) as DappPairingDataMap) : {};\n  },\n  async update(address: string, pairing?: DappPairingData) {\n    const pairings = await this.getAll();\n    if (pairing === undefined) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);\n  },\n};\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SignAndSubmitTransactionResponseArgs, SignMessageResponseArgs } from '@identity-connect/wallet-api';\nimport { UnexpectedSignatureResponseError } from './errors';\n\nconst SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS: (keyof SignMessageResponseArgs)[] = [\n  'address',\n  'application',\n  'chainId',\n  'fullMessage',\n  'message',\n  'nonce',\n  'prefix',\n  'signature',\n];\n\nexport function validateSignMessageResponse(response: SignMessageResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\nconst SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS: (keyof SignAndSubmitTransactionResponseArgs)[] = ['hash'];\n\nexport function validateSignAndSubmitTransactionResponse(response: SignAndSubmitTransactionResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(\n    (field) => !providedFields.has(field),\n  );\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { CreatePairingSerializedResponse, FinalizedPairingData, SerializedDate } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { UnregisteredDappError } from './errors';\nimport { ACPairingClient, ACPairingClientConfig } from './PairingClient';\nimport { openPrompt, waitForPromptResponse } from './prompt';\n\nexport interface ICDappClientConfig extends ACPairingClientConfig {\n  frontendBaseURL?: string;\n}\n\nexport class ICDappClient extends ACPairingClient {\n  private readonly frontendBaseURL: string;\n\n  constructor(\n    private readonly dappId: string,\n    { frontendBaseURL = DEFAULT_FRONTEND_URL, ...pairingClientConfig }: ICDappClientConfig = {},\n  ) {\n    super(pairingClientConfig);\n    this.frontendBaseURL = frontendBaseURL;\n  }\n\n  private async createPairingRequest(dappEd25519PublicKeyB64: string) {\n    try {\n      const response = await this.axiosInstance.post<CreatePairingSerializedResponse>('v1/pairing/', {\n        dappEd25519PublicKeyB64,\n        dappId: this.dappId,\n      });\n      return response.data.data.pairing;\n    } catch (err) {\n      // TODO: export typed errors from API\n      if (isAxiosError(err) && err.response?.data?.message === 'Dapp not found') {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const { publicKey, secretKey } = createEd25519KeyPair();\n    const dappEd25519PublicKeyB64 = encodeBase64(publicKey.key);\n\n    // Open the prompt without pairingId (for a snappier ux)\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n\n    let pairingId: string;\n    try {\n      const pendingPairing = await this.createPairingRequest(dappEd25519PublicKeyB64);\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      // Close the prompt and have the dapp handle the error\n      promptWindow.close();\n      throw err;\n    }\n\n    // Update the prompt's URL as soon as a pairingId is available\n    url.searchParams.set('pairingId', pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse = await waitForPromptResponse<SerializedDate<FinalizedPairingData>>(promptWindow);\n\n    if (promptResponse.status === 'dismissed') {\n      // Ignore the result. This is just a courtesy call, so if anything goes wrong\n      // the pairing will be removed during scheduled cleanup)\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return undefined;\n    }\n\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({ publicKey, secretKey }, finalizedPairing);\n\n    return finalizedPairing.account.accountAddress;\n  }\n\n  async offboard(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('This account is not paired');\n    }\n\n    const walletId = pairing.dappWalletId;\n    if (walletId === undefined) {\n      throw new Error('This account cannot be offboarded');\n    }\n\n    const url = new URL(`${this.frontendBaseURL}/offboarding?walletId=${walletId}`);\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse<{ offboarded: boolean }>(promptWindow);\n    if (response.status === 'approved' && response.args.offboarded) {\n      // If exported, disconnect the pairing to clean up\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nconst DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };\nconst PROMPT_POLLER_INTERVAL = 500;\n\nexport function openPrompt(url: string | URL, size = DEFAULT_PROMPT_SIZE) {\n  const { height, width } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width,\n  };\n\n  const strOptions = Object.entries(options)\n    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n    .reduce((acc, entry) => `${acc}, ${entry}`);\n\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, undefined, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n\n  return promptWindow;\n}\n\nexport interface PromptApproval<TResponseArgs> {\n  args: TResponseArgs;\n  status: 'approved';\n}\n\nexport interface PromptDismissal {\n  status: 'dismissed';\n}\n\nexport type PromptResponse<TResponseArgs> = PromptApproval<TResponseArgs> | PromptDismissal;\n\nexport async function waitForPromptResponse<TResponseArgs>(promptWindow: Window) {\n  return new Promise<PromptResponse<TResponseArgs>>((resolve) => {\n    const listeners = {\n      onMessage: (message: MessageEvent) => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener('message', listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: 'approved',\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: 'dismissed',\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL),\n    };\n\n    window.addEventListener('message', listeners.onMessage);\n  });\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  IsConnectedRequest,\n  IsConnectedResponse,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport { NetworkName } from '@identity-connect/api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\n\nexport interface ACKeylessClientConfig {\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n}\n\nexport class ACKeylessClient {\n  private readonly defaultNetworkName: NetworkName;\n\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n  }: ACKeylessClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL);\n  }\n\n  // region Public API\n\n  async isConnected() {\n    const serializedRequest = IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async getConnectedAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async disconnect() {\n    const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n\n  async connect() {\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args) {\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args) {\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n"],"names":["NetworkName","AccountAddress","encodeBase64","isAxiosError","createEd25519KeyPair","WebWalletTransport","GetConnectedAccountsRequest","GetConnectedAccountsResponse","DisconnectRequest","ConnectRequest","ConnectResponse","SignMessageRequest","SignMessageResponse","SignTransactionRequest","SignTransactionResponse","SignAndSubmitTransactionRequest","SignAndSubmitTransactionResponse"],"mappings":"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"}},
    {"offset": {"line": 1525, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}